// Code generated by entc, DO NOT EDIT.

package ent

import (
	"fmt"
	"time"

	"github.com/jaredallard/grocerylistsbot/ent/groceryitem"
	"github.com/jaredallard/grocerylistsbot/ent/grocerylist"
	"github.com/jaredallard/grocerylistsbot/ent/user"
	"github.com/jaredallard/grocerylistsbot/ent/useridmapping"

	"github.com/facebookincubator/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeGroceryItem   = "GroceryItem"
	TypeGroceryList   = "GroceryList"
	TypeUser          = "User"
	TypeUserIDMapping = "UserIDMapping"
)

// GroceryItemMutation represents an operation that mutate the GroceryItems
// nodes in the graph.
type GroceryItemMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	created_at         *time.Time
	modified_at        *time.Time
	deleted_at         *time.Time
	name               *string
	status             *groceryitem.Status
	price              *float64
	addprice           *float64
	clearedFields      map[string]struct{}
	grocerylist        *int
	clearedgrocerylist bool
}

var _ ent.Mutation = (*GroceryItemMutation)(nil)

// newGroceryItemMutation creates new mutation for $n.Name.
func newGroceryItemMutation(c config, op Op) *GroceryItemMutation {
	return &GroceryItemMutation{
		config:        c,
		op:            op,
		typ:           TypeGroceryItem,
		clearedFields: make(map[string]struct{}),
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GroceryItemMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GroceryItemMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *GroceryItemMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the created_at field.
func (m *GroceryItemMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the created_at value in the mutation.
func (m *GroceryItemMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt reset all changes of the created_at field.
func (m *GroceryItemMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetModifiedAt sets the modified_at field.
func (m *GroceryItemMutation) SetModifiedAt(t time.Time) {
	m.modified_at = &t
}

// ModifiedAt returns the modified_at value in the mutation.
func (m *GroceryItemMutation) ModifiedAt() (r time.Time, exists bool) {
	v := m.modified_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetModifiedAt reset all changes of the modified_at field.
func (m *GroceryItemMutation) ResetModifiedAt() {
	m.modified_at = nil
}

// SetDeletedAt sets the deleted_at field.
func (m *GroceryItemMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the deleted_at value in the mutation.
func (m *GroceryItemMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearDeletedAt clears the value of deleted_at.
func (m *GroceryItemMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[groceryitem.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the field deleted_at was cleared in this mutation.
func (m *GroceryItemMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[groceryitem.FieldDeletedAt]
	return ok
}

// ResetDeletedAt reset all changes of the deleted_at field.
func (m *GroceryItemMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, groceryitem.FieldDeletedAt)
}

// SetName sets the name field.
func (m *GroceryItemMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *GroceryItemMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// ResetName reset all changes of the name field.
func (m *GroceryItemMutation) ResetName() {
	m.name = nil
}

// SetStatus sets the status field.
func (m *GroceryItemMutation) SetStatus(gr groceryitem.Status) {
	m.status = &gr
}

// Status returns the status value in the mutation.
func (m *GroceryItemMutation) Status() (r groceryitem.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus reset all changes of the status field.
func (m *GroceryItemMutation) ResetStatus() {
	m.status = nil
}

// SetPrice sets the price field.
func (m *GroceryItemMutation) SetPrice(f float64) {
	m.price = &f
	m.addprice = nil
}

// Price returns the price value in the mutation.
func (m *GroceryItemMutation) Price() (r float64, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// AddPrice adds f to price.
func (m *GroceryItemMutation) AddPrice(f float64) {
	if m.addprice != nil {
		*m.addprice += f
	} else {
		m.addprice = &f
	}
}

// AddedPrice returns the value that was added to the price field in this mutation.
func (m *GroceryItemMutation) AddedPrice() (r float64, exists bool) {
	v := m.addprice
	if v == nil {
		return
	}
	return *v, true
}

// ClearPrice clears the value of price.
func (m *GroceryItemMutation) ClearPrice() {
	m.price = nil
	m.addprice = nil
	m.clearedFields[groceryitem.FieldPrice] = struct{}{}
}

// PriceCleared returns if the field price was cleared in this mutation.
func (m *GroceryItemMutation) PriceCleared() bool {
	_, ok := m.clearedFields[groceryitem.FieldPrice]
	return ok
}

// ResetPrice reset all changes of the price field.
func (m *GroceryItemMutation) ResetPrice() {
	m.price = nil
	m.addprice = nil
	delete(m.clearedFields, groceryitem.FieldPrice)
}

// SetGrocerylistID sets the grocerylist edge to GroceryList by id.
func (m *GroceryItemMutation) SetGrocerylistID(id int) {
	m.grocerylist = &id
}

// ClearGrocerylist clears the grocerylist edge to GroceryList.
func (m *GroceryItemMutation) ClearGrocerylist() {
	m.clearedgrocerylist = true
}

// GrocerylistCleared returns if the edge grocerylist was cleared.
func (m *GroceryItemMutation) GrocerylistCleared() bool {
	return m.clearedgrocerylist
}

// GrocerylistID returns the grocerylist id in the mutation.
func (m *GroceryItemMutation) GrocerylistID() (id int, exists bool) {
	if m.grocerylist != nil {
		return *m.grocerylist, true
	}
	return
}

// GrocerylistIDs returns the grocerylist ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// GrocerylistID instead. It exists only for internal usage by the builders.
func (m *GroceryItemMutation) GrocerylistIDs() (ids []int) {
	if id := m.grocerylist; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGrocerylist reset all changes of the grocerylist edge.
func (m *GroceryItemMutation) ResetGrocerylist() {
	m.grocerylist = nil
	m.clearedgrocerylist = false
}

// Op returns the operation name.
func (m *GroceryItemMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (GroceryItem).
func (m *GroceryItemMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *GroceryItemMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, groceryitem.FieldCreatedAt)
	}
	if m.modified_at != nil {
		fields = append(fields, groceryitem.FieldModifiedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, groceryitem.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, groceryitem.FieldName)
	}
	if m.status != nil {
		fields = append(fields, groceryitem.FieldStatus)
	}
	if m.price != nil {
		fields = append(fields, groceryitem.FieldPrice)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *GroceryItemMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case groceryitem.FieldCreatedAt:
		return m.CreatedAt()
	case groceryitem.FieldModifiedAt:
		return m.ModifiedAt()
	case groceryitem.FieldDeletedAt:
		return m.DeletedAt()
	case groceryitem.FieldName:
		return m.Name()
	case groceryitem.FieldStatus:
		return m.Status()
	case groceryitem.FieldPrice:
		return m.Price()
	}
	return nil, false
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *GroceryItemMutation) SetField(name string, value ent.Value) error {
	switch name {
	case groceryitem.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case groceryitem.FieldModifiedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModifiedAt(v)
		return nil
	case groceryitem.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case groceryitem.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case groceryitem.FieldStatus:
		v, ok := value.(groceryitem.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case groceryitem.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	}
	return fmt.Errorf("unknown GroceryItem field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *GroceryItemMutation) AddedFields() []string {
	var fields []string
	if m.addprice != nil {
		fields = append(fields, groceryitem.FieldPrice)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *GroceryItemMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case groceryitem.FieldPrice:
		return m.AddedPrice()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *GroceryItemMutation) AddField(name string, value ent.Value) error {
	switch name {
	case groceryitem.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrice(v)
		return nil
	}
	return fmt.Errorf("unknown GroceryItem numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *GroceryItemMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(groceryitem.FieldDeletedAt) {
		fields = append(fields, groceryitem.FieldDeletedAt)
	}
	if m.FieldCleared(groceryitem.FieldPrice) {
		fields = append(fields, groceryitem.FieldPrice)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *GroceryItemMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *GroceryItemMutation) ClearField(name string) error {
	switch name {
	case groceryitem.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case groceryitem.FieldPrice:
		m.ClearPrice()
		return nil
	}
	return fmt.Errorf("unknown GroceryItem nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *GroceryItemMutation) ResetField(name string) error {
	switch name {
	case groceryitem.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case groceryitem.FieldModifiedAt:
		m.ResetModifiedAt()
		return nil
	case groceryitem.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case groceryitem.FieldName:
		m.ResetName()
		return nil
	case groceryitem.FieldStatus:
		m.ResetStatus()
		return nil
	case groceryitem.FieldPrice:
		m.ResetPrice()
		return nil
	}
	return fmt.Errorf("unknown GroceryItem field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *GroceryItemMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.grocerylist != nil {
		edges = append(edges, groceryitem.EdgeGrocerylist)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *GroceryItemMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case groceryitem.EdgeGrocerylist:
		if id := m.grocerylist; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *GroceryItemMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *GroceryItemMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *GroceryItemMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedgrocerylist {
		edges = append(edges, groceryitem.EdgeGrocerylist)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *GroceryItemMutation) EdgeCleared(name string) bool {
	switch name {
	case groceryitem.EdgeGrocerylist:
		return m.clearedgrocerylist
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *GroceryItemMutation) ClearEdge(name string) error {
	switch name {
	case groceryitem.EdgeGrocerylist:
		m.ClearGrocerylist()
		return nil
	}
	return fmt.Errorf("unknown GroceryItem unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *GroceryItemMutation) ResetEdge(name string) error {
	switch name {
	case groceryitem.EdgeGrocerylist:
		m.ResetGrocerylist()
		return nil
	}
	return fmt.Errorf("unknown GroceryItem edge %s", name)
}

// GroceryListMutation represents an operation that mutate the GroceryLists
// nodes in the graph.
type GroceryListMutation struct {
	config
	op             Op
	typ            string
	id             *int
	created_at     *time.Time
	modified_at    *time.Time
	deleted_at     *time.Time
	name           *string
	clearedFields  map[string]struct{}
	members        map[int]struct{}
	removedmembers map[int]struct{}
}

var _ ent.Mutation = (*GroceryListMutation)(nil)

// newGroceryListMutation creates new mutation for $n.Name.
func newGroceryListMutation(c config, op Op) *GroceryListMutation {
	return &GroceryListMutation{
		config:        c,
		op:            op,
		typ:           TypeGroceryList,
		clearedFields: make(map[string]struct{}),
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GroceryListMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GroceryListMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *GroceryListMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the created_at field.
func (m *GroceryListMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the created_at value in the mutation.
func (m *GroceryListMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt reset all changes of the created_at field.
func (m *GroceryListMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetModifiedAt sets the modified_at field.
func (m *GroceryListMutation) SetModifiedAt(t time.Time) {
	m.modified_at = &t
}

// ModifiedAt returns the modified_at value in the mutation.
func (m *GroceryListMutation) ModifiedAt() (r time.Time, exists bool) {
	v := m.modified_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetModifiedAt reset all changes of the modified_at field.
func (m *GroceryListMutation) ResetModifiedAt() {
	m.modified_at = nil
}

// SetDeletedAt sets the deleted_at field.
func (m *GroceryListMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the deleted_at value in the mutation.
func (m *GroceryListMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearDeletedAt clears the value of deleted_at.
func (m *GroceryListMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[grocerylist.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the field deleted_at was cleared in this mutation.
func (m *GroceryListMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[grocerylist.FieldDeletedAt]
	return ok
}

// ResetDeletedAt reset all changes of the deleted_at field.
func (m *GroceryListMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, grocerylist.FieldDeletedAt)
}

// SetName sets the name field.
func (m *GroceryListMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *GroceryListMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// ResetName reset all changes of the name field.
func (m *GroceryListMutation) ResetName() {
	m.name = nil
}

// AddMemberIDs adds the members edge to User by ids.
func (m *GroceryListMutation) AddMemberIDs(ids ...int) {
	if m.members == nil {
		m.members = make(map[int]struct{})
	}
	for i := range ids {
		m.members[ids[i]] = struct{}{}
	}
}

// RemoveMemberIDs removes the members edge to User by ids.
func (m *GroceryListMutation) RemoveMemberIDs(ids ...int) {
	if m.removedmembers == nil {
		m.removedmembers = make(map[int]struct{})
	}
	for i := range ids {
		m.removedmembers[ids[i]] = struct{}{}
	}
}

// RemovedMembers returns the removed ids of members.
func (m *GroceryListMutation) RemovedMembersIDs() (ids []int) {
	for id := range m.removedmembers {
		ids = append(ids, id)
	}
	return
}

// MembersIDs returns the members ids in the mutation.
func (m *GroceryListMutation) MembersIDs() (ids []int) {
	for id := range m.members {
		ids = append(ids, id)
	}
	return
}

// ResetMembers reset all changes of the members edge.
func (m *GroceryListMutation) ResetMembers() {
	m.members = nil
	m.removedmembers = nil
}

// Op returns the operation name.
func (m *GroceryListMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (GroceryList).
func (m *GroceryListMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *GroceryListMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, grocerylist.FieldCreatedAt)
	}
	if m.modified_at != nil {
		fields = append(fields, grocerylist.FieldModifiedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, grocerylist.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, grocerylist.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *GroceryListMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case grocerylist.FieldCreatedAt:
		return m.CreatedAt()
	case grocerylist.FieldModifiedAt:
		return m.ModifiedAt()
	case grocerylist.FieldDeletedAt:
		return m.DeletedAt()
	case grocerylist.FieldName:
		return m.Name()
	}
	return nil, false
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *GroceryListMutation) SetField(name string, value ent.Value) error {
	switch name {
	case grocerylist.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case grocerylist.FieldModifiedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModifiedAt(v)
		return nil
	case grocerylist.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case grocerylist.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown GroceryList field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *GroceryListMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *GroceryListMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *GroceryListMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown GroceryList numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *GroceryListMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(grocerylist.FieldDeletedAt) {
		fields = append(fields, grocerylist.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *GroceryListMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *GroceryListMutation) ClearField(name string) error {
	switch name {
	case grocerylist.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown GroceryList nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *GroceryListMutation) ResetField(name string) error {
	switch name {
	case grocerylist.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case grocerylist.FieldModifiedAt:
		m.ResetModifiedAt()
		return nil
	case grocerylist.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case grocerylist.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown GroceryList field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *GroceryListMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.members != nil {
		edges = append(edges, grocerylist.EdgeMembers)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *GroceryListMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case grocerylist.EdgeMembers:
		ids := make([]ent.Value, 0, len(m.members))
		for id := range m.members {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *GroceryListMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedmembers != nil {
		edges = append(edges, grocerylist.EdgeMembers)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *GroceryListMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case grocerylist.EdgeMembers:
		ids := make([]ent.Value, 0, len(m.removedmembers))
		for id := range m.removedmembers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *GroceryListMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *GroceryListMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *GroceryListMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown GroceryList unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *GroceryListMutation) ResetEdge(name string) error {
	switch name {
	case grocerylist.EdgeMembers:
		m.ResetMembers()
		return nil
	}
	return fmt.Errorf("unknown GroceryList edge %s", name)
}

// UserMutation represents an operation that mutate the Users
// nodes in the graph.
type UserMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	created_at         *time.Time
	modified_at        *time.Time
	deleted_at         *time.Time
	name               *string
	clearedFields      map[string]struct{}
	grocerylist        map[int]struct{}
	removedgrocerylist map[int]struct{}
	active_list        *int
	clearedactive_list bool
}

var _ ent.Mutation = (*UserMutation)(nil)

// newUserMutation creates new mutation for $n.Name.
func newUserMutation(c config, op Op) *UserMutation {
	return &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the created_at field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the created_at value in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt reset all changes of the created_at field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetModifiedAt sets the modified_at field.
func (m *UserMutation) SetModifiedAt(t time.Time) {
	m.modified_at = &t
}

// ModifiedAt returns the modified_at value in the mutation.
func (m *UserMutation) ModifiedAt() (r time.Time, exists bool) {
	v := m.modified_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetModifiedAt reset all changes of the modified_at field.
func (m *UserMutation) ResetModifiedAt() {
	m.modified_at = nil
}

// SetDeletedAt sets the deleted_at field.
func (m *UserMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the deleted_at value in the mutation.
func (m *UserMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearDeletedAt clears the value of deleted_at.
func (m *UserMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[user.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the field deleted_at was cleared in this mutation.
func (m *UserMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[user.FieldDeletedAt]
	return ok
}

// ResetDeletedAt reset all changes of the deleted_at field.
func (m *UserMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, user.FieldDeletedAt)
}

// SetName sets the name field.
func (m *UserMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *UserMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// ResetName reset all changes of the name field.
func (m *UserMutation) ResetName() {
	m.name = nil
}

// AddGrocerylistIDs adds the grocerylist edge to GroceryList by ids.
func (m *UserMutation) AddGrocerylistIDs(ids ...int) {
	if m.grocerylist == nil {
		m.grocerylist = make(map[int]struct{})
	}
	for i := range ids {
		m.grocerylist[ids[i]] = struct{}{}
	}
}

// RemoveGrocerylistIDs removes the grocerylist edge to GroceryList by ids.
func (m *UserMutation) RemoveGrocerylistIDs(ids ...int) {
	if m.removedgrocerylist == nil {
		m.removedgrocerylist = make(map[int]struct{})
	}
	for i := range ids {
		m.removedgrocerylist[ids[i]] = struct{}{}
	}
}

// RemovedGrocerylist returns the removed ids of grocerylist.
func (m *UserMutation) RemovedGrocerylistIDs() (ids []int) {
	for id := range m.removedgrocerylist {
		ids = append(ids, id)
	}
	return
}

// GrocerylistIDs returns the grocerylist ids in the mutation.
func (m *UserMutation) GrocerylistIDs() (ids []int) {
	for id := range m.grocerylist {
		ids = append(ids, id)
	}
	return
}

// ResetGrocerylist reset all changes of the grocerylist edge.
func (m *UserMutation) ResetGrocerylist() {
	m.grocerylist = nil
	m.removedgrocerylist = nil
}

// SetActiveListID sets the active_list edge to GroceryList by id.
func (m *UserMutation) SetActiveListID(id int) {
	m.active_list = &id
}

// ClearActiveList clears the active_list edge to GroceryList.
func (m *UserMutation) ClearActiveList() {
	m.clearedactive_list = true
}

// ActiveListCleared returns if the edge active_list was cleared.
func (m *UserMutation) ActiveListCleared() bool {
	return m.clearedactive_list
}

// ActiveListID returns the active_list id in the mutation.
func (m *UserMutation) ActiveListID() (id int, exists bool) {
	if m.active_list != nil {
		return *m.active_list, true
	}
	return
}

// ActiveListIDs returns the active_list ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// ActiveListID instead. It exists only for internal usage by the builders.
func (m *UserMutation) ActiveListIDs() (ids []int) {
	if id := m.active_list; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetActiveList reset all changes of the active_list edge.
func (m *UserMutation) ResetActiveList() {
	m.active_list = nil
	m.clearedactive_list = false
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.modified_at != nil {
		fields = append(fields, user.FieldModifiedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, user.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, user.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldModifiedAt:
		return m.ModifiedAt()
	case user.FieldDeletedAt:
		return m.DeletedAt()
	case user.FieldName:
		return m.Name()
	}
	return nil, false
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldModifiedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModifiedAt(v)
		return nil
	case user.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case user.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldDeletedAt) {
		fields = append(fields, user.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldModifiedAt:
		m.ResetModifiedAt()
		return nil
	case user.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case user.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.grocerylist != nil {
		edges = append(edges, user.EdgeGrocerylist)
	}
	if m.active_list != nil {
		edges = append(edges, user.EdgeActiveList)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeGrocerylist:
		ids := make([]ent.Value, 0, len(m.grocerylist))
		for id := range m.grocerylist {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeActiveList:
		if id := m.active_list; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedgrocerylist != nil {
		edges = append(edges, user.EdgeGrocerylist)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeGrocerylist:
		ids := make([]ent.Value, 0, len(m.removedgrocerylist))
		for id := range m.removedgrocerylist {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedactive_list {
		edges = append(edges, user.EdgeActiveList)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeActiveList:
		return m.clearedactive_list
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	case user.EdgeActiveList:
		m.ClearActiveList()
		return nil
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeGrocerylist:
		m.ResetGrocerylist()
		return nil
	case user.EdgeActiveList:
		m.ResetActiveList()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// UserIDMappingMutation represents an operation that mutate the UserIDMappings
// nodes in the graph.
type UserIDMappingMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	modified_at   *time.Time
	deleted_at    *time.Time
	platform_type *useridmapping.PlatformType
	platform_id   *string
	clearedFields map[string]struct{}
	user          *int
	cleareduser   bool
}

var _ ent.Mutation = (*UserIDMappingMutation)(nil)

// newUserIDMappingMutation creates new mutation for $n.Name.
func newUserIDMappingMutation(c config, op Op) *UserIDMappingMutation {
	return &UserIDMappingMutation{
		config:        c,
		op:            op,
		typ:           TypeUserIDMapping,
		clearedFields: make(map[string]struct{}),
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserIDMappingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserIDMappingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *UserIDMappingMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the created_at field.
func (m *UserIDMappingMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the created_at value in the mutation.
func (m *UserIDMappingMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt reset all changes of the created_at field.
func (m *UserIDMappingMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetModifiedAt sets the modified_at field.
func (m *UserIDMappingMutation) SetModifiedAt(t time.Time) {
	m.modified_at = &t
}

// ModifiedAt returns the modified_at value in the mutation.
func (m *UserIDMappingMutation) ModifiedAt() (r time.Time, exists bool) {
	v := m.modified_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetModifiedAt reset all changes of the modified_at field.
func (m *UserIDMappingMutation) ResetModifiedAt() {
	m.modified_at = nil
}

// SetDeletedAt sets the deleted_at field.
func (m *UserIDMappingMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the deleted_at value in the mutation.
func (m *UserIDMappingMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearDeletedAt clears the value of deleted_at.
func (m *UserIDMappingMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[useridmapping.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the field deleted_at was cleared in this mutation.
func (m *UserIDMappingMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[useridmapping.FieldDeletedAt]
	return ok
}

// ResetDeletedAt reset all changes of the deleted_at field.
func (m *UserIDMappingMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, useridmapping.FieldDeletedAt)
}

// SetPlatformType sets the platform_type field.
func (m *UserIDMappingMutation) SetPlatformType(ut useridmapping.PlatformType) {
	m.platform_type = &ut
}

// PlatformType returns the platform_type value in the mutation.
func (m *UserIDMappingMutation) PlatformType() (r useridmapping.PlatformType, exists bool) {
	v := m.platform_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetPlatformType reset all changes of the platform_type field.
func (m *UserIDMappingMutation) ResetPlatformType() {
	m.platform_type = nil
}

// SetPlatformID sets the platform_id field.
func (m *UserIDMappingMutation) SetPlatformID(s string) {
	m.platform_id = &s
}

// PlatformID returns the platform_id value in the mutation.
func (m *UserIDMappingMutation) PlatformID() (r string, exists bool) {
	v := m.platform_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetPlatformID reset all changes of the platform_id field.
func (m *UserIDMappingMutation) ResetPlatformID() {
	m.platform_id = nil
}

// SetUserID sets the user edge to User by id.
func (m *UserIDMappingMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the user edge to User.
func (m *UserIDMappingMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared returns if the edge user was cleared.
func (m *UserIDMappingMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the user id in the mutation.
func (m *UserIDMappingMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the user ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserIDMappingMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser reset all changes of the user edge.
func (m *UserIDMappingMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Op returns the operation name.
func (m *UserIDMappingMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (UserIDMapping).
func (m *UserIDMappingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *UserIDMappingMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, useridmapping.FieldCreatedAt)
	}
	if m.modified_at != nil {
		fields = append(fields, useridmapping.FieldModifiedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, useridmapping.FieldDeletedAt)
	}
	if m.platform_type != nil {
		fields = append(fields, useridmapping.FieldPlatformType)
	}
	if m.platform_id != nil {
		fields = append(fields, useridmapping.FieldPlatformID)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *UserIDMappingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case useridmapping.FieldCreatedAt:
		return m.CreatedAt()
	case useridmapping.FieldModifiedAt:
		return m.ModifiedAt()
	case useridmapping.FieldDeletedAt:
		return m.DeletedAt()
	case useridmapping.FieldPlatformType:
		return m.PlatformType()
	case useridmapping.FieldPlatformID:
		return m.PlatformID()
	}
	return nil, false
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *UserIDMappingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case useridmapping.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case useridmapping.FieldModifiedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModifiedAt(v)
		return nil
	case useridmapping.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case useridmapping.FieldPlatformType:
		v, ok := value.(useridmapping.PlatformType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlatformType(v)
		return nil
	case useridmapping.FieldPlatformID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlatformID(v)
		return nil
	}
	return fmt.Errorf("unknown UserIDMapping field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *UserIDMappingMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *UserIDMappingMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *UserIDMappingMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserIDMapping numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *UserIDMappingMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(useridmapping.FieldDeletedAt) {
		fields = append(fields, useridmapping.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *UserIDMappingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserIDMappingMutation) ClearField(name string) error {
	switch name {
	case useridmapping.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown UserIDMapping nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *UserIDMappingMutation) ResetField(name string) error {
	switch name {
	case useridmapping.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case useridmapping.FieldModifiedAt:
		m.ResetModifiedAt()
		return nil
	case useridmapping.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case useridmapping.FieldPlatformType:
		m.ResetPlatformType()
		return nil
	case useridmapping.FieldPlatformID:
		m.ResetPlatformID()
		return nil
	}
	return fmt.Errorf("unknown UserIDMapping field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *UserIDMappingMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, useridmapping.EdgeUser)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *UserIDMappingMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case useridmapping.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *UserIDMappingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *UserIDMappingMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *UserIDMappingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, useridmapping.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *UserIDMappingMutation) EdgeCleared(name string) bool {
	switch name {
	case useridmapping.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *UserIDMappingMutation) ClearEdge(name string) error {
	switch name {
	case useridmapping.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown UserIDMapping unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *UserIDMappingMutation) ResetEdge(name string) error {
	switch name {
	case useridmapping.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown UserIDMapping edge %s", name)
}
